hw06
================
Victoria Michalowski
November 9, 2017

2. Writing Functions
====================

starting point: the linear regression function example
------------------------------------------------------

First, load the Gapminder data.

``` r
library(gapminder)
```

    ## Warning: package 'gapminder' was built under R version 3.3.3

``` r
library(tidyverse)
```

    ## Warning: package 'tidyverse' was built under R version 3.3.3

    ## Loading tidyverse: ggplot2
    ## Loading tidyverse: tibble
    ## Loading tidyverse: tidyr
    ## Loading tidyverse: readr
    ## Loading tidyverse: purrr
    ## Loading tidyverse: dplyr

    ## Warning: package 'ggplot2' was built under R version 3.3.2

    ## Warning: package 'tidyr' was built under R version 3.3.3

    ## Warning: package 'readr' was built under R version 3.3.2

    ## Warning: package 'purrr' was built under R version 3.3.3

    ## Warning: package 'dplyr' was built under R version 3.3.3

    ## Conflicts with tidy packages ----------------------------------------------

    ## filter(): dplyr, stats
    ## lag():    dplyr, stats

Extract data for one country.

``` r
j_country <- "Finland" #pick a country, but do not hard wire
(j_dat <- gapminder %>% 
    filter(country == j_country))
```

    ## # A tibble: 12 × 6
    ##    country continent  year lifeExp     pop gdpPercap
    ##     <fctr>    <fctr> <int>   <dbl>   <int>     <dbl>
    ## 1  Finland    Europe  1952  66.550 4090500  6424.519
    ## 2  Finland    Europe  1957  67.490 4324000  7545.415
    ## 3  Finland    Europe  1962  68.750 4491443  9371.843
    ## 4  Finland    Europe  1967  69.830 4605744 10921.636
    ## 5  Finland    Europe  1972  70.870 4639657 14358.876
    ## 6  Finland    Europe  1977  72.520 4738902 15605.423
    ## 7  Finland    Europe  1982  74.550 4826933 18533.158
    ## 8  Finland    Europe  1987  74.830 4931729 21141.012
    ## 9  Finland    Europe  1992  75.700 5041039 20647.165
    ## 10 Finland    Europe  1997  77.130 5134406 23723.950
    ## 11 Finland    Europe  2002  78.370 5193039 28204.591
    ## 12 Finland    Europe  2007  79.313 5238460 33207.084

Plot the data.

``` r
p <- ggplot(j_dat, aes(x = year, y = lifeExp))
p + geom_point() + geom_smooth(method = "lm", se = FALSE)
```

![](hw06_files/figure-markdown_github-ascii_identifiers/unnamed-chunk-3-1.png)

Fit the regression.

``` r
j_fit <- lm(lifeExp ~ year, j_dat)
coef(j_fit)
```

    ##  (Intercept)         year 
    ## -397.9809669    0.2379252

The intercept here suggests that life expectancy in Finland was almost minus 400 years at year 0 A.D. This doesn't make sense, so reparametrization is called for. It makes more sense to have the intercept correspond to life expectancy in 1952, the first measurement point in the gapminder dataset.

``` r
j_fit <- lm(lifeExp ~ I(year - 1952), j_dat) #I() function inhibits interpretation/conversion of objects
coef(j_fit)
```

    ##    (Intercept) I(year - 1952) 
    ##     66.4489744      0.2379252

This intercept makes more sense, and by eyeballing the plot above, we can tell that it's in line with the data and more interpretable.

Turn this working code into a function.
---------------------------------------

Drop the working code into the basic definition of a function.

``` r
le_linear_fit <- function(dat, offset = 1952) {
  the_fit <- lm(lifeExp ~ I(year - offset), dat)
  coef(the_fit)
}
le_linear_fit(j_dat)
```

    ##      (Intercept) I(year - offset) 
    ##       66.4489744        0.2379252

Notice we get the same result as before. The names on this return value are not intuitive - fix names next to make them interpretable.

``` r
le_linear_fit <- function(dat, offset = 1952) {
  the_fit <- lm(lifeExp ~ I(year - offset), dat)
  setNames(coef(the_fit), c("intercept", "slope"))
}
le_linear_fit(j_dat)
```

    ##  intercept      slope 
    ## 66.4489744  0.2379252

Rotate through other examples in a clean workspace
--------------------------------------------------

It's a good idea to test your function on other data during development. The most common catch is accidental hard-wires of examples in the function.

``` r
j_country <- "Brazil"
(j_dat <- gapminder %>% 
    filter(country == j_country))
```

    ## # A tibble: 12 × 6
    ##    country continent  year lifeExp       pop gdpPercap
    ##     <fctr>    <fctr> <int>   <dbl>     <int>     <dbl>
    ## 1   Brazil  Americas  1952  50.917  56602560  2108.944
    ## 2   Brazil  Americas  1957  53.285  65551171  2487.366
    ## 3   Brazil  Americas  1962  55.665  76039390  3336.586
    ## 4   Brazil  Americas  1967  57.632  88049823  3429.864
    ## 5   Brazil  Americas  1972  59.504 100840058  4985.711
    ## 6   Brazil  Americas  1977  61.489 114313951  6660.119
    ## 7   Brazil  Americas  1982  63.336 128962939  7030.836
    ## 8   Brazil  Americas  1987  65.205 142938076  7807.096
    ## 9   Brazil  Americas  1992  67.057 155975974  6950.283
    ## 10  Brazil  Americas  1997  69.388 168546719  7957.981
    ## 11  Brazil  Americas  2002  71.006 179914212  8131.213
    ## 12  Brazil  Americas  2007  72.390 190010647  9065.801

``` r
p1 <- ggplot(j_dat, aes(x = year, y = lifeExp))
p1 + geom_point() + geom_smooth(method = "lm", se = FALSE)
```

![](hw06_files/figure-markdown_github-ascii_identifiers/unnamed-chunk-8-1.png)

``` r
le_linear_fit(j_dat)
```

    ##  intercept      slope 
    ## 51.5120385  0.3900895

The regression results seem to match up with the visual line.

Next, I cleaned out my workspace, re-ran the minimum amount of code, and re-tested my function. This will help avoid accidentally relying on objects that were left over from development, but are not actually defined in the function code.

``` r
rm(list = ls())

le_linear_fit <- function(dat, offset = 1952) {
  the_fit <- lm(lifeExp ~ I((year - offset)^2), dat)
  setNames(coef(the_fit), c("intercept", "slope"))
}
le_linear_fit(gapminder %>% 
                filter(country == "Sweden"))
```

    ##   intercept       slope 
    ## 73.17566063  0.00284712

generalize: quadratic regression
--------------------------------

Include a squared term to extend the example from a linear regression to a quadratic regression.

``` r
le_quadratic_fit <- function(dat, offset = 1952) {
  the_fit2 <- lm(lifeExp ~ I(year - offset) + I((year - offset)^2), dat)
  setNames(coef(the_fit2), c("intercept", "Year Slope", "Year^2 Slope"))
}

le_quadratic_fit(gapminder %>% 
                   filter(country == "Sweden"))
```

    ##    intercept   Year Slope Year^2 Slope 
    ## 7.186599e+01 1.349359e-01 5.694306e-04

6. Work with a nested data frame
================================

Nest the data by country and continent.
---------------------------------------

Nesting is an extension of grouping. Unlike grouping though, the collapse to a single row per group happens right away. The non-grouping variables are packaged into group-specific data frames that are held in a list-column. Then the computation to the components of this list gets applied.

First, group, and then nest. Group by country and continent.

``` r
(gap_nested <- gapminder %>% 
   group_by(continent, country) %>% 
   nest())
```

    ## # A tibble: 142 × 3
    ##    continent     country              data
    ##       <fctr>      <fctr>            <list>
    ## 1       Asia Afghanistan <tibble [12 × 4]>
    ## 2     Europe     Albania <tibble [12 × 4]>
    ## 3     Africa     Algeria <tibble [12 × 4]>
    ## 4     Africa      Angola <tibble [12 × 4]>
    ## 5   Americas   Argentina <tibble [12 × 4]>
    ## 6    Oceania   Australia <tibble [12 × 4]>
    ## 7     Europe     Austria <tibble [12 × 4]>
    ## 8       Asia     Bahrain <tibble [12 × 4]>
    ## 9       Asia  Bangladesh <tibble [12 × 4]>
    ## 10    Europe     Belgium <tibble [12 × 4]>
    ## # ... with 132 more rows

Note: - we collapsed to 142 rows, with one row per country - continent and country remain - there is a new "data"" variable, and this variable is a list: a list-column, in which the non-grouping variables are held.

Let's try to inspect the new list-column.

``` r
gap_nested[[1, "data"]]
```

    ## # A tibble: 12 × 4
    ##     year lifeExp      pop gdpPercap
    ##    <int>   <dbl>    <int>     <dbl>
    ## 1   1952  28.801  8425333  779.4453
    ## 2   1957  30.332  9240934  820.8530
    ## 3   1962  31.997 10267083  853.1007
    ## 4   1967  34.020 11537966  836.1971
    ## 5   1972  36.088 13079460  739.9811
    ## 6   1977  38.438 14880372  786.1134
    ## 7   1982  39.854 12881816  978.0114
    ## 8   1987  40.822 13867957  852.3959
    ## 9   1992  41.674 16317921  649.3414
    ## 10  1997  41.763 22227415  635.3414
    ## 11  2002  42.129 25268405  726.7341
    ## 12  2007  43.828 31889923  974.5803

``` r
#or

gap_nested[["data"]][[1]]
```

    ## # A tibble: 12 × 4
    ##     year lifeExp      pop gdpPercap
    ##    <int>   <dbl>    <int>     <dbl>
    ## 1   1952  28.801  8425333  779.4453
    ## 2   1957  30.332  9240934  820.8530
    ## 3   1962  31.997 10267083  853.1007
    ## 4   1967  34.020 11537966  836.1971
    ## 5   1972  36.088 13079460  739.9811
    ## 6   1977  38.438 14880372  786.1134
    ## 7   1982  39.854 12881816  978.0114
    ## 8   1987  40.822 13867957  852.3959
    ## 9   1992  41.674 16317921  649.3414
    ## 10  1997  41.763 22227415  635.3414
    ## 11  2002  42.129 25268405  726.7341
    ## 12  2007  43.828 31889923  974.5803

``` r
#or

gap_nested$data[[1]]
```

    ## # A tibble: 12 × 4
    ##     year lifeExp      pop gdpPercap
    ##    <int>   <dbl>    <int>     <dbl>
    ## 1   1952  28.801  8425333  779.4453
    ## 2   1957  30.332  9240934  820.8530
    ## 3   1962  31.997 10267083  853.1007
    ## 4   1967  34.020 11537966  836.1971
    ## 5   1972  36.088 13079460  739.9811
    ## 6   1977  38.438 14880372  786.1134
    ## 7   1982  39.854 12881816  978.0114
    ## 8   1987  40.822 13867957  852.3959
    ## 9   1992  41.674 16317921  649.3414
    ## 10  1997  41.763 22227415  635.3414
    ## 11  2002  42.129 25268405  726.7341
    ## 12  2007  43.828 31889923  974.5803

Apply a function.

Let's try to iterate over the elements of gap\_nested$data, using purrr::map().

First, fit a model to the data from Sweden.

``` r
(fit <- lm(lifeExp ~ I(year - 1952), data = gap_nested[[123,"data"]]))
```

    ## 
    ## Call:
    ## lm(formula = lifeExp ~ I(year - 1952), data = gap_nested[[123, 
    ##     "data"]])
    ## 
    ## Coefficients:
    ##    (Intercept)  I(year - 1952)  
    ##        71.6050          0.1663

Capture that logic in a function, and test whether it returns that same results for Sweden as above.

``` r
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  summary(quad_fit)
}
le_vs_yr(gap_nested[[123, "data"]])
```

    ## 
    ## Call:
    ## lm(formula = lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
    ## 
    ## Residuals:
    ##      Min       1Q   Median       3Q      Max 
    ## -0.15528 -0.07843 -0.01053  0.02716  0.29880 
    ## 
    ## Coefficients:
    ##                     Estimate Std. Error t value Pr(>|t|)    
    ## (Intercept)        7.187e+01  1.040e-01 691.173  < 2e-16 ***
    ## I(year - 1952)     1.349e-01  8.789e-03  15.353 9.22e-08 ***
    ## I((year - 1952)^2) 5.694e-04  1.540e-04   3.698  0.00493 ** 
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 0.1406 on 9 degrees of freedom
    ## Multiple R-squared:  0.9982, Adjusted R-squared:  0.9978 
    ## F-statistic:  2505 on 2 and 9 DF,  p-value: 4.376e-13

Use the broom package to get information out of my quadratic model.
-------------------------------------------------------------------

``` r
library(broom)
```

    ## Warning: package 'broom' was built under R version 3.3.3

``` r
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  tidy(quad_fit)
}
le_vs_yr(gap_nested[[123, "data"]])
```

    ##                 term     estimate    std.error  statistic      p.value
    ## 1        (Intercept) 7.186599e+01 0.1039767746 691.173479 1.414340e-22
    ## 2     I(year - 1952) 1.349359e-01 0.0087888456  15.353082 9.215544e-08
    ## 3 I((year - 1952)^2) 5.694306e-04 0.0001539693   3.698339 4.933237e-03

Now we have a data.frame representation, with the row names moved into the column called term, and the column names are simple and consistent (can access using $).

What if you are interested in the fitted values and residuals for each of the original points in the regression?

Use augment, which augments the original data with information from the model.

``` r
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  head(augment(quad_fit))
}
le_vs_yr(gap_nested[[123, "data"]])
```

    ##   lifeExp I.year...1952. I..year...1952..2.  .fitted    .se.fit
    ## 1   71.86              0                  0 71.86599 0.10397677
    ## 2   72.49              5                 25 72.55490 0.07400810
    ## 3   73.37             10                100 73.27229 0.05782396
    ## 4   74.16             15                225 74.01815 0.05466271
    ## 5   74.72             20                400 74.79248 0.05782396
    ## 6   75.44             25                625 75.59528 0.06082111
    ##         .resid      .hat    .sigma     .cooksd  .std.resid
    ## 1 -0.005989011 0.5467033 0.1491215 0.001608624 -0.06325623
    ## 2 -0.064904096 0.2769730 0.1466930 0.037621009 -0.54279315
    ## 3  0.097709291 0.1690809 0.1442598 0.039410016  0.76224748
    ## 4  0.141851149 0.1510989 0.1388675 0.071116534  1.09482275
    ## 5 -0.072478521 0.1690809 0.1464816 0.021684706 -0.56541778
    ## 6 -0.155279720 0.1870629 0.1361602 0.115043248 -1.22468890

Each new column (e.g. .fitted, .se.fit, etc.) begins with a . to avoid overwritting original columns.

Access summary statistics (such as R^2 and the F-statistic) with the glance function.

``` r
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  glance(quad_fit)
}
le_vs_yr(gap_nested[[123, "data"]])
```

    ##   r.squared adj.r.squared     sigma statistic      p.value df   logLik
    ## 1  0.998207     0.9978086 0.1406243  2505.297 4.376052e-13  3 8.238788
    ##         AIC      BIC  deviance df.residual
    ## 1 -8.477577 -6.53795 0.1779768           9

Explore the estimated coefficients
----------------------------------

Scale up to all countries by putting the function inside a dyplr::do() call.

``` r
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
    setNames(data.frame(t(coef(quad_fit))), c("intercept", "slope", "slope^2"))
}
gfits_me <- gapminder %>%
  group_by(country) %>% 
  do(le_vs_yr(.))
gfits_me
```

    ## Source: local data frame [142 x 4]
    ## Groups: country [142]
    ## 
    ##        country intercept     slope     `slope^2`
    ##         <fctr>     <dbl>     <dbl>         <dbl>
    ## 1  Afghanistan  28.17869 0.4827616 -3.771508e-03
    ## 2      Albania  56.85313 0.6198024 -5.183986e-03
    ## 3      Algeria  41.94224 0.7412083 -3.125974e-03
    ## 4       Angola  30.11767 0.4504179 -4.383237e-03
    ## 5    Argentina  62.71818 0.2281386  6.490509e-05
    ## 6    Australia  69.18927 0.1330727  1.720929e-03
    ## 7      Austria  66.81158 0.1984181  7.922577e-04
    ## 8      Bahrain  50.25452 0.7668703 -5.442957e-03
    ## 9   Bangladesh  37.47247 0.3376929  2.917053e-03
    ## 10     Belgium  68.11067 0.1828346  4.772727e-04
    ## # ... with 132 more rows

Let's try some plots.

``` r
ggplot(gfits_me, aes(x = intercept)) + geom_density() + geom_rug()
```

![](hw06_files/figure-markdown_github-ascii_identifiers/unnamed-chunk-19-1.png)

``` r
ggplot(gfits_me, aes(x = slope)) + geom_density() + geom_rug()
```

![](hw06_files/figure-markdown_github-ascii_identifiers/unnamed-chunk-20-1.png)

``` r
ggplot(gfits_me, aes(x = intercept, y = slope)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

    ## `geom_smooth()` using method = 'loess'

![](hw06_files/figure-markdown_github-ascii_identifiers/unnamed-chunk-21-1.png)
