---
title: "hw06"
author: "Victoria Michalowski"
date: "November 9, 2017"
output: github_document
---

# 2. Writing Functions

## starting point: the linear regression function example

First, load the Gapminder data.

```{r}
library(gapminder)
library(tidyverse)
```

Extract data for one country.

```{r}
j_country <- "Finland" #pick a country, but do not hard wire
(j_dat <- gapminder %>% 
    filter(country == j_country))
```

Plot the data.

```{r}
p <- ggplot(j_dat, aes(x = year, y = lifeExp))
p + geom_point() + geom_smooth(method = "lm", se = FALSE)
```

Fit the regression.

```{r}
j_fit <- lm(lifeExp ~ year, j_dat)
coef(j_fit)
```

The intercept here suggests that life expectancy in Finland was almost minus 400 years at year 0 A.D. This doesn't make sense, so reparametrization is called for. It makes more sense to have the intercept correspond to life expectancy in 1952, the first measurement point in the gapminder dataset.

```{r}
j_fit <- lm(lifeExp ~ I(year - 1952), j_dat) #I() function inhibits interpretation/conversion of objects
coef(j_fit)
```

This intercept makes more sense, and by eyeballing the plot above, we can tell that it's in line with the data and more interpretable.

## Turn this working code into a function.

Drop the working code into the basic definition of a function.

```{r}
le_linear_fit <- function(dat, offset = 1952) {
  the_fit <- lm(lifeExp ~ I(year - offset), dat)
  coef(the_fit)
}
le_linear_fit(j_dat)
```

Notice we get the same result as before. The names on this return value are not intuitive - fix names next to make them interpretable.

```{r}
le_linear_fit <- function(dat, offset = 1952) {
  the_fit <- lm(lifeExp ~ I(year - offset), dat)
  setNames(coef(the_fit), c("intercept", "slope"))
}
le_linear_fit(j_dat)
```

## Rotate through other examples in a clean workspace

It's a good idea to test your function on other data during development. The most common catch is accidental hard-wires of examples in the function.

```{r}
j_country <- "Brazil"
(j_dat <- gapminder %>% 
    filter(country == j_country))

p1 <- ggplot(j_dat, aes(x = year, y = lifeExp))
p1 + geom_point() + geom_smooth(method = "lm", se = FALSE)

le_linear_fit(j_dat)
```

The regression results seem to match up with the visual line.

Next, I cleaned out my workspace, re-ran the minimum amount of code, and re-tested my function. This will help avoid accidentally relying on objects that were left over from development, but are not actually defined in the function code.

```{r}
rm(list = ls())

le_linear_fit <- function(dat, offset = 1952) {
  the_fit <- lm(lifeExp ~ I((year - offset)^2), dat)
  setNames(coef(the_fit), c("intercept", "slope"))
}
le_linear_fit(gapminder %>% 
                filter(country == "Sweden"))
```

## generalize: quadratic regression

Include a squared term to extend the example from a linear regression to a quadratic regression.

```{r}
le_quadratic_fit <- function(dat, offset = 1952) {
  the_fit2 <- lm(lifeExp ~ I(year - offset) + I((year - offset)^2), dat)
  setNames(coef(the_fit2), c("intercept", "Year Slope", "Year^2 Slope"))
}

le_quadratic_fit(gapminder %>% 
                   filter(country == "Sweden"))
```


# 6. Work with a nested data frame

## Nest the data by country and continent.

Nesting is an extension of grouping. Unlike grouping though, the collapse to a single row per group happens right away. The non-grouping variables are packaged into group-specific data frames that are held in a list-column. Then the computation to the components of this list gets applied.

First, group, and then nest. Group by country and continent.

```{r}
(gap_nested <- gapminder %>% 
   group_by(continent, country) %>% 
   nest())
```

Note: 
- we collapsed to 142 rows, with one row per country
- continent and country remain
- there is a new "data"" variable, and this variable is a list: a list-column, in which the non-grouping variables are held.

Let's try to inspect the new list-column.

```{r}
gap_nested[[1, "data"]]

#or

gap_nested[["data"]][[1]]

#or

gap_nested$data[[1]]
```

Apply a function.

Let's try to iterate over the elements of gap_nested$data, using purrr::map().

First, fit a model to the data from Sweden.

```{r}
(fit <- lm(lifeExp ~ I(year - 1952), data = gap_nested[[123,"data"]]))
```

Capture that logic in a function, and test whether it returns that same results for Sweden as above.

```{r}
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  summary(quad_fit)
}
le_vs_yr(gap_nested[[123, "data"]])
```

## Use the broom package to get information out of my quadratic model.

```{r}
library(broom)

le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  tidy(quad_fit)
}
le_vs_yr(gap_nested[[123, "data"]])
```

Now we have a data.frame representation, with the row names moved into the column called term, and the column names are simple and consistent (can access using $).

What if you are interested in the fitted values and residuals for each of the original points in the regression?

Use augment, which augments the original data with information from the model.

```{r}
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  head(augment(quad_fit))
}
le_vs_yr(gap_nested[[123, "data"]])
```

Each new column (e.g. .fitted, .se.fit, etc.) begins with a . to avoid overwritting original columns.

Access summary statistics (such as R^2 and the F-statistic) with the glance function.

```{r}
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
  glance(quad_fit)
}
le_vs_yr(gap_nested[[123, "data"]])
```

## Explore the estimated coefficients

Scale up to all countries by putting the function inside a dyplr::do() call.

```{r}
le_vs_yr <- function(df) {
  quad_fit <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), data = df)
    setNames(data.frame(t(coef(quad_fit))), c("intercept", "slope", "slope^2"))
}
gfits_me <- gapminder %>%
  group_by(country) %>% 
  do(le_vs_yr(.))
gfits_me
```

Let's try some plots.

```{r}
ggplot(gfits_me, aes(x = intercept)) + geom_density() + geom_rug()
```

```{r}
ggplot(gfits_me, aes(x = slope)) + geom_density() + geom_rug()
```

```{r}
ggplot(gfits_me, aes(x = intercept, y = slope)) +
  geom_point() +
  geom_smooth(se = FALSE)
```




